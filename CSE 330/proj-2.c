#include "sem.h"
#include <stdlib.h>

int buff, producers, consumers, N;
int line, num;
int in = 0, out = 0;
int* Buffer;

struct SemQueue FullQ; // consumer
struct SemQueue EmptyQ; // producer

void producer_Funct(int threadID)
{
    for(int i = 0; i < N; i++)
    {
        while(EmptyQ.value <= 0)
        {
            printf("\n Producer %d is waiting \n", threadID);
            P(&EmptyQ);
        }
        P(&EmptyQ);
        if(Buffer[in] == 0)
        {
            printf("\n Producer %d is producing item number %d \n", threadID, i + 1);
            Buffer[in] = threadID;
            in = (in + 1) % buff;
        }

        V(&FullQ);

        if(i+1 == N)
        {
            ucontext_t* previous = &(RunQ.head->context);
            DelQueue(&RunQ);
            swapcontext(previous, &(RunQ.head->context));
        }
        else
            yield();
    }
}

void consumer_Funct(int threadID)
{
    for(int i = 0; i < N; i++)
    {
        while(FullQ.value <= 0)
        {
            printf("\n Consumer %d is waiting \n", threadID * -1);
            P(&FullQ);
        }
        P(&FullQ);
        if(Buffer[out] != 0)
        {
            printf("\n Consumer %d is consuming item generated by Producer %d \n", abs(threadID), Buffer[out]);
            Buffer[out] = 0;
            out = (out + 1) % buff;
        }

        V(&EmptyQ);

        if(i+1 == N)
        {
            ucontext_t* previous = &(RunQ.head->context);
            DelQueue(&RunQ);
            swapcontext(previous, &(RunQ.head->context));
        }
        else
            yield();
    }
}

int main()
{
    scanf("%d,%d,%d,%d", &buff, &producers, &consumers, &N); 
    InitSem(&FullQ,0);
    InitSem(&EmptyQ,buff);

    InitQueue(&RunQ);

    Buffer = (int*)malloc(buff * sizeof(int));
    line = producers + consumers;

    if (N == 0)
        return 0;
    else
    {
        for (int i = 0; i < line; i++)
        {
            scanf("%d", &num);

            if(num < 0) // consumer
                start_thread(&consumer_Funct, num);
            else if(num > 0) //producer
                start_thread(&producer_Funct, num);
        }
    }

    run();

    return 0;
}